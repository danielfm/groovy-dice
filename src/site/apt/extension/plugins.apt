 --------
 Plug-ins

Plug-ins

 Groovy Dice provides a powerful way to extend - and even replace - the
 built-in API by using a simple plug-in architecture.

* Creating plug-ins

** A simple example

 Here goes a simple plug-in that adds a method to dice rolling command objects:

+-------------------------------------------------------------------------------------+
class HitchhikersGuideToTheGalaxy {

    /* this closure is called during the Groovy Dice initialization */
    def dynamicMethods = { api ->
        api.add(method:'is_the_answer_to_life_the_universe_and_everything') { dice ->
            dice.allDice.sum() == 42
        }
    }
}

/* register the plug-in at the initialization step */
def config = new GroovyDice()
config.pluginManager.register(new HitchhikersGuideToTheGalaxy())
config.initialize()

5.d10.is_the_answer_to_life_the_universe_and_everything
+-------------------------------------------------------------------------------------+

 Every plug-in must provide a method/closure called <<<dynamicMethods>>>. This
 closure/method receives an instance of
 {{{../apidocs/net/sf/groovydice/plugin/GroovyDiceAPI.html}GroovyDiceAPI}}
 which you can use to register new methods to the API.

 In this example we added a method to check whether the sum of all dice is
 equals to <<<42>>>.

** A plug-in can use methods added by another

 We can make that example even better. You probably know that Groovy Dice
 have a built-in
 {{{../apidocs/net/sf/groovydice/plugin/builtin/DiceStatisticsPlugin.html}plug-in}}
 that already provides a <<<sum>>> method. Then, our plug-in can use this
 method to make things easier:

+-------------------------------------------------------------------------------------+
class HitchhikersGuideToTheGalaxy {

    /* this closure is called during the Groovy Dice initialization */
    def dynamicMethods = { api ->
        api.add(method:'is_the_answer_to_life_the_universe_and_everything') { obj ->
            if (api.isCommand(obj)) {
                return obj.sum == 42 // using a method provided by another plug-in
            }
        }
    }
}

/* the rest remains the same... */
+-------------------------------------------------------------------------------------+

** Plug-in lifecycle events

 At this time, the only lifecycle event that a plug-in can listen to is the
 <<<onInitialize>>> event, which is invoked when the <<<initialize()>>> method
 is called on the corresponding <<<GroovyDice>>> object:

+-----------------------------------------------------------------------+
class MyPlugin {

    GroovyDice config

    def onInitialize = { config ->
        /* we can save the reference to 'config' */
        this.config = config
    }

    def dynamicMethods = { api ->
        // ...
    }
}

def config = new GroovyDice()
config.pluginManager.register(new MyPlugin())

/* this triggers the 'onInitialize' event on the registered plugins */
config.initialize()
+-----------------------------------------------------------------------+

 Your plug-ins don't have to have such closure to work. The only practical
 reason you would use this feature is because your plugin needs the
 <<<GroovyDice>>> object to do its job.

** Several plug-ins can implement the same method collaboratively

 You can simulate some sort of polymorfism by writing several plugins that
 provides an implementation to the same method. An example:

+--------------------------------------------------------------------------------+
class FirstPlugin {

    def dynamicMethods = { api ->
        api.add(method:'looks_like', to:api.numberClasses) { num, obj ->
            if (obj instanceof Date) {
                return "First: $num - $obj"
            }
        }
    }
}

class SecondPlugin {

    def dynamicMethods = { api ->
        api.add(method:'looks_like', to:api.numberClasses) { num, obj ->
            if (obj instanceof Integer) {
                return "Second: $num - $obj"
            }
        }
    }
}

def config = new GroovyDice()

config.pluginManager.register(new FirstPlugin())
config.pluginManager.register(new SecondPlugin())

config.initialize()

println 10.looks_like(20)                     // prints "Second: 10 - 20"
println 10.looks_like(new Date())             // prints "First: 10 - (time)"
println 10.looks_like{ println 'A closure!' } // no plugin can handle a closure!
+--------------------------------------------------------------------------------+

 In this example we have two plugins that "listens" to the same method
 call, but the first plugin only comes into scene when the given object
 is a <<<Date>>> and the second plugin only do it's job when the given
 object is an <<<Integer>>>. To give every plug-in a chance to execute,
 Groovy Dice will try to call every method registered under that name.

 Since the plug-in registration order is relevant, Groovy Dice calls
 first the <<<FirstPlugin>>> instance, passing to it the called
 <<<Integer>>> instance and the given parameter (<<<10>>> and
 <<<20>>>, respectively). Since the parameter is an <<<Integer>>>,
 the closure returns nothing and then the other registered closures
 are called.

 This process continues until some plug-in returns a valid value. In
 this example, the closure provided by <<<SecondPlugin>>> returns
 something valid and then the process stops <<even if there are other
 plug-ins that can handle the call>>. If no plug-in can handle the
 call, Groovy Dice will raise an exception.

** Plug-ins can use regex patterns as method names

 If you want to add a method under a name that matches a particular
 pattern, you are allowed to use regular expressions:

+-------------------------------------------------------+
class HelloPlugin {

    def dynamicMethods = { api ->
        api.add(method:/say.*/, to:Integer) { number ->
            'Hello!'
        }
    }
}

/* register the plug-in at the initialization step */

10.say
10.sayHello
10.saySomething
+-------------------------------------------------------+

 This feature is pretty useful when you want to intercept a method
 which you don't know exactly the name. But there's a problem: if you
 want to the method name that has triggered your plug-in, you should mark
 a method name as <dynamic> when adding it to the API:

+-----------------------------------------------------------------------------------+
class HelloPlugin {

    def dynamicMethods = { api ->
        api.add(dynamicMethod:/say.*/, to:Integer) { name, number ->
            "$name - $number"
        }
    }
}

/* register the plug-in at the initialization step */

10.say          // prints "say - 10"
10.sayHello     // prints "sayHello - 10"
10.saySomething // prints "saySomething - 10"
+-----------------------------------------------------------------------------------+

 In this example, we specify the method name using the <<<dynamicMethod>>>
 instead of <<<method>>>. Doing this, your closure will get the method name
 in the first parameter and the called object in the second parameter.

** Limitations

 You <<can't>> add methods to any class you want; you are restricted to
 numbers and the
 {{{../apidocs/net/sf/groovydice/DiceRollingCommand.html}dice rolling command}}.

* Manipulating the built-in stack

 Most of Groovy Dice's features were implemented as plug-ins, which make your life
 easier when you need to change the default plug-in stack.

 The following example shows some examples:

+------------------------------------------------------------------------------+
def config = new GroovyDice()
def manager = config.pluginManager

def plugin = new MyPlugin()

manager.register(plugin)     // register a new plugin to the stack
manager.unregister(plugin)   // unregister a particular plugin instance
manager.unregister(MyPlugin) // unregister all MyPlugin instances
manager.unregister()         // removes all registered plugins
+------------------------------------------------------------------------------+