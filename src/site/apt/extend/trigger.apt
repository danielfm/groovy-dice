 ------------------
 Expression Trigger

Expression Trigger

 The expression trigger is the one that makes the DSL magic happen.

* A simple example

 In this example, let's say you want to introduce a new element to the Groovy
 Dice syntax:

+---------------------
6.dx  // rolls six three-sided dice
8.dx  // rolls eight four-sided dice
12.dx // rolls twelve six-sided dice
20.dx // rolls twenty ten-sided dice
+---------------------

 Can you figure out a pattern in these scripts? Yes, you're right: when the
 user evaluates a dice expression like y.dx we should roll y (y/2)-sided dice.

 Ok, here goes the code to make this happen:

+---------------------
import net.sf.groovydice.*

class MyExpressionTrigger extends ExpressionTrigger {

    void addMethods() {
        super.addMethods()
        numberClasses.each {
            it.metaClass.getDx = { ->
                rollCommand(delegate, delegate/2 as int)
            }
        }
    }
}
+---------------------

 Don't be scared about stuff like <<<numberClasses.each>>> and
 <<<rollCommand(...)>>>. The
 {{{../apidocs/net/sf/groovydice/ExpressionTrigger.html}documentation}} is here to
 save your day.

** Replacing the default expression trigger

 To make Groovy Dice use <your> implementation instead the default one, we need to
 pass a <<<MyExpressionTrigger>>> instance to <<<expressionTrigger>>> property, on
 the <<<GroovyDice>>> object:
 
+---------------------
new GroovyDice(expressionTrigger:new MyExpressionTrigger()).initialize()
+---------------------
 
 That's it, Groovy Dice will use the provided expression trigger instance
 during the initialization.

** Can I replace the expression trigger instance after the initialization?

 Unfortunately you can't because the <<<addMethods()>>> method (which is the
 one who does the dirty work) only gets invoked when the Groovy Dice engine
 is initialized.

+---------------------
def config = new GroovyDice()
config.initialize()

12.dx // error

// after a while...
config.expressionTrigger = new MyExpressionTrigger()
config.initialize() // re-initialize*

12.dx // ok, same as 12.d6
+---------------------

 <<*Note:>> a call to <<<initialize()>>> starts that process of dynamically add
 methods to the Groovy API. So, if you call <<<initialize()>>> twice, the methods
 added by the first call <<won't>> be removed when the second call is done.